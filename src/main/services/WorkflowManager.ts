import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { DELOCommandSystem, DeloContext, DeloCommandResult } from './DELOCommandSystem';
import { EnhancedAIPromptingService } from './EnhancedAIPromptingService';
import { DatabaseManager } from './DatabaseManager';

export interface WorkflowStep {
  id: string;
  command: string;
  args?: any;
  condition?: string; // AI-evaluated condition
  fallback?: string; // What to do if step fails
  description: string;
}

export interface Workflow {
  id: string;
  name: string;
  description: string;
  trigger: string; // Natural language trigger
  steps: WorkflowStep[];
  context: string[]; // When this workflow applies
  tags: string[];
  usageCount: number;
  successRate: number;
  lastUsed: number;
  isAutoGenerated: boolean;
  confidence: number;
}

export interface WorkflowExecution {
  workflowId: string;
  startTime: number;
  endTime?: number;
  steps: Array<{
    stepId: string;
    status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';
    result?: DeloCommandResult;
    error?: string;
  }>;
  context: DeloContext;
  success: boolean;
}

export interface PatternDetection {
  pattern: string[];
  frequency: number;
  lastSeen: number;
  suggestedWorkflow?: Workflow;
  confidence: number;
}

export class WorkflowManager {
  private workflows: Map<string, Workflow> = new Map();
  private executions: WorkflowExecution[] = [];
  private patterns: PatternDetection[] = [];
  private deloSystem: DELOCommandSystem;
  private enhancedAI: EnhancedAIPromptingService;
  private databaseManager: DatabaseManager;
  private workflowsPath: string;
  private patternsPath: string;
  private isInitialized = false;

  constructor(deloSystem: DELOCommandSystem) {
    this.deloSystem = deloSystem;
    this.enhancedAI = new EnhancedAIPromptingService();
    this.databaseManager = DatabaseManager.getInstance();
    this.workflowsPath = path.join(os.homedir(), '.doppel', 'workflows.json');
    this.patternsPath = path.join(os.homedir(), '.doppel', 'patterns.json');
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      console.log('üîÑ Initializing Workflow Manager...');
      
      // Ensure directories exist
      const dir = path.dirname(this.workflowsPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Load existing workflows and patterns
      this.loadWorkflows();
      this.loadPatterns();
      
      // Initialize default workflows
      this.initializeDefaultWorkflows();
      
      this.isInitialized = true;
      console.log('‚úÖ Workflow Manager initialized');
    } catch (error) {
      console.error('‚ùå Error initializing Workflow Manager:', error);
      throw error;
    }
  }

  /**
   * Execute a workflow by name or trigger
   */
  public async executeWorkflow(trigger: string, context: DeloContext): Promise<WorkflowExecution> {
    const workflow = this.findWorkflow(trigger, context);
    if (!workflow) {
      throw new Error(`No workflow found for trigger: ${trigger}`);
    }

    const execution: WorkflowExecution = {
      workflowId: workflow.id,
      startTime: Date.now(),
      steps: workflow.steps.map(step => ({
        stepId: step.id,
        status: 'pending'
      })),
      context,
      success: false
    };

    console.log(`üöÄ Executing workflow: ${workflow.name}`);

    try {
      for (let i = 0; i < workflow.steps.length; i++) {
        const step = workflow.steps[i];
        const stepExecution = execution.steps[i];
        
        stepExecution.status = 'running';
        
        // Check condition if present
        if (step.condition) {
          const shouldExecute = await this.evaluateCondition(step.condition, context);
          if (!shouldExecute) {
            stepExecution.status = 'skipped';
            continue;
          }
        }

        try {
          // Execute the step
          const result = await this.deloSystem.processCommand(step.command);
          stepExecution.result = result;
          stepExecution.status = result.success ? 'completed' : 'failed';
          
          if (!result.success && step.fallback) {
            console.log(`üîÑ Executing fallback for step: ${step.id}`);
            const fallbackResult = await this.deloSystem.processCommand(step.fallback);
            stepExecution.result = fallbackResult;
            stepExecution.status = fallbackResult.success ? 'completed' : 'failed';
          }
        } catch (error) {
          stepExecution.status = 'failed';
          stepExecution.error = String(error);
        }
      }

      execution.endTime = Date.now();
      execution.success = execution.steps.every(step => step.status === 'completed' || step.status === 'skipped');
      
      // Update workflow stats
      this.updateWorkflowStats(workflow.id, execution.success);
      
      // Save execution history
      this.executions.push(execution);
      if (this.executions.length > 100) {
        this.executions.shift();
      }

      console.log(`‚úÖ Workflow completed: ${workflow.name} (${execution.success ? 'success' : 'failed'})`);
      return execution;

    } catch (error) {
      execution.endTime = Date.now();
      execution.success = false;
      console.error('‚ùå Workflow execution failed:', error);
      return execution;
    }
  }

  /**
   * Auto-detect patterns from user actions and suggest workflows
   */
  public async detectPatterns(recentActions: string[]): Promise<PatternDetection[]> {
    if (recentActions.length < 3) return [];

    // Use AI to analyze patterns
    const analysis = await this.enhancedAI.analyzeIntent(recentActions.join(' '));
    
    // Look for repeated sequences
    const sequences = this.findRepeatedSequences(recentActions);
    
    const patterns: PatternDetection[] = [];
    
    for (const sequence of sequences) {
      if (sequence.frequency >= 2) { // At least 2 occurrences
        const suggestedWorkflow = await this.generateWorkflowFromPattern(sequence.pattern);
        
        patterns.push({
          pattern: sequence.pattern,
          frequency: sequence.frequency,
          lastSeen: Date.now(),
          suggestedWorkflow,
          confidence: this.calculatePatternConfidence(sequence)
        });
      }
    }

    // Update patterns
    this.patterns = patterns;
    this.savePatterns();
    
    return patterns;
  }

  /**
   * Generate a workflow from a detected pattern
   */
  private async generateWorkflowFromPattern(pattern: string[]): Promise<Workflow> {
    const workflowId = `auto_${Date.now()}`;
    const steps: WorkflowStep[] = pattern.map((action, index) => ({
      id: `step_${index}`,
      command: action,
      description: `Auto-generated step ${index + 1}`
    }));

    return {
      id: workflowId,
      name: `Auto Workflow - ${pattern.slice(0, 2).join(' ‚Üí ')}`,
      description: `Automatically generated workflow from pattern: ${pattern.join(' ‚Üí ')}`,
      trigger: `auto ${pattern[0]}`,
      steps,
      context: ['auto-generated'],
      tags: ['auto', 'pattern'],
      usageCount: 0,
      successRate: 0,
      lastUsed: 0,
      isAutoGenerated: true,
      confidence: 0.8
    };
  }

  /**
   * Find workflow by trigger or name
   */
  private findWorkflow(trigger: string, context: DeloContext): Workflow | null {
    // First, try exact match
    for (const workflow of this.workflows.values()) {
      if (workflow.trigger.toLowerCase() === trigger.toLowerCase()) {
        return workflow;
      }
    }

    // Then, try fuzzy matching
    let bestMatch: Workflow | null = null;
    let bestScore = 0;

    for (const workflow of this.workflows.values()) {
      const score = this.calculateWorkflowMatchScore(workflow, trigger, context);
      if (score > bestScore && score > 0.7) {
        bestScore = score;
        bestMatch = workflow;
      }
    }

    return bestMatch;
  }

  /**
   * Calculate how well a workflow matches a trigger
   */
  private calculateWorkflowMatchScore(workflow: Workflow, trigger: string, context: DeloContext): number {
    let score = 0;

    // Check trigger similarity
    const triggerSimilarity = this.calculateStringSimilarity(workflow.trigger.toLowerCase(), trigger.toLowerCase());
    score += triggerSimilarity * 0.6;

    // Check context relevance
    const contextRelevance = this.calculateContextRelevance(workflow.context, context);
    score += contextRelevance * 0.4;

    return score;
  }

  /**
   * Calculate string similarity using Levenshtein distance
   */
  private calculateStringSimilarity(str1: string, str2: string): number {
    const maxLen = Math.max(str1.length, str2.length);
    if (maxLen === 0) return 1;
    
    // Simple Levenshtein implementation
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));
    
    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;
    
    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j][i] = Math.min(
          matrix[j][i - 1] + 1,
          matrix[j - 1][i] + 1,
          matrix[j - 1][i - 1] + indicator
        );
      }
    }
    
    return 1 - (matrix[str2.length][str1.length] / maxLen);
  }

  /**
   * Calculate context relevance
   */
  private calculateContextRelevance(workflowContext: string[], userContext: DeloContext): number {
    if (workflowContext.length === 0) return 0.5;

    let matches = 0;
    const contextText = `${userContext.activeApp} ${userContext.windowTitle} ${userContext.clipboardContent}`.toLowerCase();

    for (const context of workflowContext) {
      if (contextText.includes(context.toLowerCase())) {
        matches++;
      }
    }

    return matches / workflowContext.length;
  }

  /**
   * Find repeated sequences in recent actions
   */
  private findRepeatedSequences(actions: string[]): Array<{ pattern: string[], frequency: number }> {
    const sequences: Array<{ pattern: string[], frequency: number }> = [];
    
    // Look for sequences of 2-4 actions
    for (let length = 2; length <= Math.min(4, actions.length); length++) {
      for (let start = 0; start <= actions.length - length; start++) {
        const pattern = actions.slice(start, start + length);
        const patternStr = pattern.join('|');
        
        let frequency = 1;
        for (let i = start + 1; i <= actions.length - length; i++) {
          const comparePattern = actions.slice(i, i + length);
          if (comparePattern.join('|') === patternStr) {
            frequency++;
          }
        }
        
        if (frequency > 1) {
          sequences.push({ pattern, frequency });
        }
      }
    }
    
    return sequences.sort((a, b) => b.frequency - a.frequency);
  }

  /**
   * Calculate pattern confidence
   */
  private calculatePatternConfidence(sequence: { pattern: string[], frequency: number }): number {
    // Higher frequency = higher confidence
    const frequencyScore = Math.min(sequence.frequency / 3, 1);
    
    // Longer patterns = higher confidence
    const lengthScore = Math.min(sequence.pattern.length / 4, 1);
    
    return (frequencyScore * 0.7) + (lengthScore * 0.3);
  }

  /**
   * Evaluate AI condition
   */
  private async evaluateCondition(condition: string, context: DeloContext): Promise<boolean> {
    try {
      const prompt = `Evaluate this condition: "${condition}"
      
Context:
- Active App: ${context.activeApp}
- Window: ${context.windowTitle}
- Clipboard: ${context.clipboardContent.substring(0, 200)}
- Recent Commands: ${context.recentCommands.join(', ')}

Respond with only "true" or "false":`;

      const analysis = await this.enhancedAI.analyzeIntent(prompt);
      return analysis.intent.toLowerCase().includes('true');
    } catch (error) {
      console.error('Error evaluating condition:', error);
      return true; // Default to executing if condition evaluation fails
    }
  }

  /**
   * Update workflow statistics
   */
  private updateWorkflowStats(workflowId: string, success: boolean): void {
    const workflow = this.workflows.get(workflowId);
    if (!workflow) return;

    workflow.usageCount++;
    workflow.lastUsed = Date.now();
    
    if (success) {
      workflow.successRate = ((workflow.successRate * (workflow.usageCount - 1)) + 1) / workflow.usageCount;
    } else {
      workflow.successRate = (workflow.successRate * (workflow.usageCount - 1)) / workflow.usageCount;
    }

    this.saveWorkflows();
  }

  /**
   * Initialize default workflows
   */
  private initializeDefaultWorkflows(): void {
    const defaultWorkflows: Workflow[] = [
      {
        id: 'meeting_notes_workflow',
        name: 'Process Meeting Notes',
        description: 'Summarize meeting notes and send follow-up email',
        trigger: 'process meeting notes',
        steps: [
          {
            id: 'summarize',
            command: 'summarize this',
            description: 'Summarize the meeting notes'
          },
          {
            id: 'email',
            command: 'email this summary to team',
            description: 'Send summary email to team'
          },
          {
            id: 'calendar',
            command: 'open calendar',
            description: 'Open calendar for follow-up scheduling'
          }
        ],
        context: ['meeting', 'zoom', 'teams'],
        tags: ['meeting', 'productivity'],
        usageCount: 0,
        successRate: 0,
        lastUsed: 0,
        isAutoGenerated: false,
        confidence: 0.9
      },
      {
        id: 'research_workflow',
        name: 'Research Assistant',
        description: 'Search, summarize, and save research findings',
        trigger: 'research this topic',
        steps: [
          {
            id: 'search',
            command: 'search for this topic',
            description: 'Search the web for information'
          },
          {
            id: 'summarize',
            command: 'summarize search results',
            description: 'Summarize the findings'
          },
          {
            id: 'save',
            command: 'save this to research folder',
            description: 'Save findings to research folder'
          }
        ],
        context: ['research', 'study', 'learning'],
        tags: ['research', 'learning'],
        usageCount: 0,
        successRate: 0,
        lastUsed: 0,
        isAutoGenerated: false,
        confidence: 0.9
      }
    ];

    for (const workflow of defaultWorkflows) {
      if (!this.workflows.has(workflow.id)) {
        this.workflows.set(workflow.id, workflow);
      }
    }
  }

  /**
   * Save workflows to file
   */
  private saveWorkflows(): void {
    try {
      const workflowsArray = Array.from(this.workflows.values());
      fs.writeFileSync(this.workflowsPath, JSON.stringify(workflowsArray, null, 2));
    } catch (error) {
      console.error('Error saving workflows:', error);
    }
  }

  /**
   * Load workflows from file
   */
  private loadWorkflows(): void {
    try {
      if (fs.existsSync(this.workflowsPath)) {
        const data = fs.readFileSync(this.workflowsPath, 'utf8');
        const workflowsArray = JSON.parse(data);
        this.workflows.clear();
        for (const workflow of workflowsArray) {
          this.workflows.set(workflow.id, workflow);
        }
      }
    } catch (error) {
      console.error('Error loading workflows:', error);
    }
  }

  /**
   * Save patterns to file
   */
  private savePatterns(): void {
    try {
      fs.writeFileSync(this.patternsPath, JSON.stringify(this.patterns, null, 2));
    } catch (error) {
      console.error('Error saving patterns:', error);
    }
  }

  /**
   * Load patterns from file
   */
  private loadPatterns(): void {
    try {
      if (fs.existsSync(this.patternsPath)) {
        const data = fs.readFileSync(this.patternsPath, 'utf8');
        this.patterns = JSON.parse(data);
      }
    } catch (error) {
      console.error('Error loading patterns:', error);
    }
  }

  /**
   * Get all workflows
   */
  public getWorkflows(): Workflow[] {
    return Array.from(this.workflows.values());
  }

  /**
   * Get detected patterns
   */
  public getPatterns(): PatternDetection[] {
    return this.patterns;
  }

  /**
   * Add a new workflow
   */
  public addWorkflow(workflow: Omit<Workflow, 'id' | 'usageCount' | 'successRate' | 'lastUsed'>): string {
    const id = `workflow_${Date.now()}`;
    const newWorkflow: Workflow = {
      ...workflow,
      id,
      usageCount: 0,
      successRate: 0,
      lastUsed: 0
    };
    
    this.workflows.set(id, newWorkflow);
    this.saveWorkflows();
    return id;
  }

  /**
   * Delete a workflow
   */
  public deleteWorkflow(workflowId: string): boolean {
    const deleted = this.workflows.delete(workflowId);
    if (deleted) {
      this.saveWorkflows();
    }
    return deleted;
  }
} 